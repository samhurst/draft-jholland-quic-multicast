



QUIC Working Group                                            J. Holland
Internet-Draft                                 Akamai Technologies, Inc.
Intended status: Experimental                                  L. Pardue
Expires: 17 October 2022                                   15 April 2022


                      Multicast Extension for QUIC
                  draft-jholland-quic-multicast-latest

Abstract

   This document defines a multicast extension to QUIC to enable the
   efficient use of mullticast-capable networks to send identical data
   streams to many clients at once, coordinated through individual
   unicast QUIC connections.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://GrumpyOldTroll.github.io/draft-jholland-quic-multicast/draft-
   jholland-quic-multicast.html.  Status information for this document
   may be found at https://datatracker.ietf.org/doc/draft-jholland-quic-
   multicast/.

   Discussion of this document takes place on the QUIC Individual Draft
   mailing list (mailto:quic@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/browse/quic/.

   Source for this draft and an issue tracker can be found at
   https://github.com/GrumpyOldTroll/draft-jholland-quic-multicast.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 17 October 2022.

Copyright Notice

   Copyright (c) 2022 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
     1.1.  Conventions and Definitions
   2.  Handshake Negotiation and Transport Parameter
   3.  Multicast Session
   4.  Extension Overview
     4.1.  Session Management
     4.2.  Client Response
     4.3.  Data Carried in Sessions
     4.4.  Stream Processing
   5.  Flow Control
   6.  Congestion Control
   7.  Packet Scheduling
   8.  Implementation and Operational Considerations
   9.  New Frames
     9.1.  MC_SESSION_PROPERTIES
     9.2.  MC_SESSION_JOIN
     9.3.  MC_SESSION_LEAVE
     9.4.  MC_SESSION_INTEGRITY
     9.5.  MC_SESSION_STREAM_BOUNDARY_OFFSET
     9.6.  MC_SESSION_ACK
     9.7.  MC_PATH_RESPONSE
     9.8.  MC_CLIENT_LIMITS
     9.9.  MC_SESSION_RETIRE
     9.10. MC_CLIENT_SESSION_STATE
   10. Frames Carried in Session Packets
   11. Error Codes
   12. Security Considerations
   13. IANA Considerations
   14. Normative References
   Acknowledgments
   Authors' Addresses

1.  Introduction

   This document specifies an extension to QUIC version 1 [RFC9000] to
   enable the use of multicast IP transport of identical data packets
   for use in many individual QUIC connections.

   The multicast data can only be consumed in conjunction with a unicast
   QUIC connection.  When support for multicast is negotiated, the
   server can optionally advertise existence of one or more multicst
   channels that contain unidirectional data streams from server to
   client, and the client can optionally join the multicast channel and
   verify from integrity data the server provides that correct data is
   being received, then acknowledge the data from the multicast
   channel(s) over the unicast connection.

   Enabling this can provide large scalability benefits for popular
   traffic over multicast-capable networks.

   This document does not define any multicast transport except server
   to client.

1.1.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

2.  Handshake Negotiation and Transport Parameter

   TODO (next)

3.  Multicast Session

   A multicast session (or just session) is a one-way communication
   stream by which a server can transport data to a client as part of
   the QUIC connection between the server and client.

   Multicast sessions are additional network paths that can optionally
   be used by the server and client to transport application data
   concurrently with other network paths used by the connection.

   Sessions are designed to leverage multicast IP, so all clients joined
   to a session will receive identical data packets for that session at
   the IP layer.  Sessions are designed to be shared by many connections
   so that many servers can use the same session to communicate the same
   data to many clients.

   Note that each QUIC connection still is defined only between a single
   client and a single server.  But when using the multicast extension
   defined in this document, some of the data transmitted from server to
   client may be data that used a network transport path that was shared
   with other connections.

   The use of any particular session is OPTIONAL for both the server and
   the client.  It is recommended that applications designed to leverage
   the multicast capabilities of this extension also provide graceeful
   degradation for endpoints that do not or cannot make use of the
   multicast functionality.

   The server has access to all data transmitted on any multicast
   session it uses, and could optionally send this data with unicast
   instead.  An application using a multicast-capable QUIC
   implementation that receives a datagram or stream data has no
   knowledge at the application layer whether multicast was used or not
   used for that data, it will only know it has received unidirectional
   server-to-client application data.

4.  Extension Overview

   A client has the option of refusal and the power to impose upper
   bound maxima on several resources (see Section 5), but otherwise its
   join status for all multicast sessions is entirely managed by the
   server.

   *  A client MUST NOT join a session without receiving instructions
      from a server to do so

   *  A client MUST leave joined sessions when instructed by the server
      to do so

   *  A client MAY leave sessions or refuse to join sessions, regardless
      of instructions from the server

4.1.  Session Management

   The client tells its server about some restrictions on resources that
   the server's instructions must remain within using MC_CLIENT_LIMITS
   Section 9.8 frames as covered in Section 5.

   The server asks the client to join sessions with MC_SESSION_JOIN
   (Section 9.2) frames and to leave sessions with MC_SESSION_LEAVE
   (Section 9.3) frames.

   The server uses MC_SESSION_PROPERTIES (Section 9.1) frames before any
   join or leave frames for the session to describe the session
   properties to the client, including values the client can use to
   ensure the server's requests remain within the limits it has sent to
   the server, as well as the keys necessary to decode packets in the
   session.

   When the server has asked the client to join a session, it also sends
   MC_SESSION_INTEGRITY (Section 9.4 frames to enable the client to
   verify packet integrity before processing the packet.  A client MUST
   NOT decode packets for a session for which it has not received an
   applicable set of MC_SESSION_PROPERTIES (Section 9.1) frames
   containing the full set of data required, or for which it has not
   received a matching packet hash in an MC_SESSION_INTEGRITY
   (Section 9.4) frame.

   The server ensures that in aggregate, all sessions that the client
   has currently been asked to join and that the client has not left or
   declined to join fit within the limits indicated by the last
   MC_CLIENT_LIMITS (Section 9.8) frame the server received.

4.2.  Client Response

   The client sends back information about how it has responded to the
   server's requests to join and leave sessions in
   MC_CLIENT_SESSION_STATE (Section 9.10) frames.
   MC_CLIENT_SESSION_STATE frames are only sent for sessions after the
   server has requested the client to join the session, and are
   thereafter sent any time the state changes.

   The client also sends back acknowledgements of data packets received
   from joined sessions with MC_SESSION_ACK (Section 9.6) frames.

   Clients that receive and decode data on a multicast session send
   acknowledgements for the data on a unicast session using
   MC_SESSION_ACK frames.  Sessions also will periodically contain
   PATH_CHALLENGE ([RFC9000] Section 19.17) frames, which cause clients
   to send MC_PATH_RESPONSE (Section 9.7) frames on the unicast
   connection in addition to their MC_SESSION_ACK frames.

4.3.  Data Carried in Sessions

   Data transmitted in a multicast session is encrypted with symmetric
   keys so that on-path observers without access to these keys cannot
   decode the data.  However, since potentially many receivers receive
   identical packets and identical keys for the multicast session and
   some receivers might be malicious, the packets are also protected by
   MC_SESSION_INTEGRITY (Section 9.4) frames transmitted over a separate
   integrity-protected path.

   A client MUST NOT decode packets on a multicast session for which it
   has not received a matching hash in an MC_SESSION_INTEGRITY frame
   over a different integrity-protected communication path.  The
   different path can be either the unicast connection or another
   multicast session with packets that were verified with an earlier
   MC_SESSION_INTEGRITY frame.

4.4.  Stream Processing

   Stream IDs in sessions are restricted to unidirectional server
   initiated streams, or those with the least significant 2 bits of the
   stream ID equal to 3 (see [RFC9000] Section 2.1).

   Since a server has access to all data in sessions it uses, a server
   can always avoid stream ID collisions with the stream IDs carried in
   sessions, and can usually (depending on the timing) avoid allowing
   sessions to exceed the client's max_streams_uni by requesting that
   clients leave sessions before their limits would be exceeded.

   However, since clients can join later than a session began, clients
   supporting the multicast extensions to QUIC should be prepared to
   handle stream IDs that do not begin at early values, since by the
   time a client joins a session in progress the stream id count might
   have been increasing for a long time.  Clients should therefore begin
   with a high initial_max_streams_uni or send an early MAX_STREAMS type
   0x13 value (see Section 19.11 of [RFC9000]) with a high limit.

   MC_SESSION_PROPERTIES can provide a recommended value for
   max_streams_uni to allow for uninterrupted transport using the
   multicast session.

   Servers also can send MC_SESSION_STREAM_BOUNDARY_OFFSET (Section 9.5)
   frames to indicate an application-layer boundary in a stream carried
   inside a session.  These frames enable new clients joining a session
   to start receiving application data from the indicated stream as
   though the stream data at that offset had an offset of 0.

5.  Flow Control

   The values used for unicast flow control cannot be used to limit the
   transmission rate of a multicast session because a single client with
   a low MAX_STREAM_DATA or MAX_DATA value that did not acknowledge
   receipt could block many other receivers if the servers had to ensure
   that sessions responded to each client's limits.

   Instead, clients advertise resource limits that the server is
   responsible for staying within via MC_CLIENT_LIMITS (Section 9.8)
   frames.  The server advertises the expected maxima of the values that
   can contribute toward client resource limits within a session in
   MC_SESSION_PROPERTIES (Section 9.1) frames.

   If the server asks the client to join a session that would exceed the
   client's limits with an up-to-date Client Limit Sequence Number, the
   client shoud send back a MC_SESSION_STATE_CHANGE with "Declined Join"
   and reason "Protocol Violation".  If the server asks the client to
   join a session that would exceed the client's limits with an out-of-
   date Client Limit Sequence Number or a Session Property Sequence
   Number that the client has not yet seen, the client should instead
   send back a "Declined Join" with "Desynchronized Limit Violation".
   If the actual contents sent in the session exceed the advertised
   limits from the MC_SESSION_PROPERTY, clients SHOULD leave the stream
   with a PROTOCOL_ERROR/Limit Violated state change.

6.  Congestion Control

   The server maintains a full view of the traffic received by the
   client via the ACK frames coupled with the MC_SESSION_ACK
   (Section 9.6) frames.

   Under sustained persistent loss, the server SHOULD instruct the
   client such that the aggregate rate of joined sessions remains under
   the data rate successfully received by the client in the recent past.

7.  Packet Scheduling

8.  Implementation and Operational Considerations

9.  New Frames

9.1.  MC_SESSION_PROPERTIES

   An MC_SESSION_PROPERTIES frame (type=TBD-01) is sent from server to
   client, either with the unicast connection or in an existing joined
   multicast session.

   A server can send an update to a prior MC_SESSION_PROPERTIES with a
   new sequence number increased by one.  Any values omitted by not
   setting the corresponding Selector bit remain unchanged from their
   last value.  It is RECOMMENDED that servers set an Until Packet
   Number and send regular updates to the MC_SESSION_PROPERTIES before
   the packet numbers in the session exceed that value.

   A client cannot join a multicast session without first receiving a
   set of MC_SESSION_PROPERTIES frames that set each of the values for
   the session.

   MC_SESSION_PROPERTIES frames are formatted as shown in Figure 1.

   MC_SESSION_PROPERTIES Frame {
     Type (i) = TBD-01 (experiments use 0xff3e8001),
     Session ID (i),
     Properties Sequence Number (i),
     From Packet Number (32),
     Selectors (12) {
       Has Until Packet Number (1),
       Has Key (1),
       Has Header Key (1),
       Has Hash Algorithm (1),
       Has Max Rate (1),
       Has Max Idle Time (1),
       Has Recommended Max Streams (1),
       Has SSM (1),
       Has Addresses (1),
       IP Family (4)
     },
     Reserved (3),
     Until Packet Number (0..32),
     AEAD Algorithm (0..16),
     Key (...),
     Header AEAD Algorithm (0..16),
     Header Key (...),
     Integrity Hash Algorithm (0..8),
     Max Rate (0..i),
     Max Idle Time (0..i),
     Recommended Max Streams (0..i),
     Source IP (...),
     Group IP (...),
     UDP Port (0..16)
   }

                Figure 1: MC_SESSION_PROPERTIES Frame Format

   The 'Has' fields in the Selector determine presence or absence of the
   corresponding values in the rest of the frame.  If a field is not
   included, it remains unchanged unless a different semantic is
   explained below.

   *  From Packet Number, Until Packet Number: the changes given in this
      MC_SESSION_PROPERTIES frame apply to packets starting at From
      Packet Number and continuing until Until Packet Number-1.  If
      Until Packet Number is omitted it indicates the current property
      values for this session do not expire at any packet number.

   *  AEAD Algorithm: a value from https://www.iana.org/assignments/
      aead-parameters/aead-parameters.xhtml
      (https://www.iana.org/assignments/aead-parameters/aead-
      parameters.xhtml).  Both this field and the Key field are present
      if and only if Has Key is set, and the length of the following Key
      field is determined by the algorithm value.  The algorithm value
      provided MUST be a value listed as supported by the client in the
      transport properties during initial negotiation.

   *  Key: present if and only if Has Key is set, with length determined
      by the AEAD Algorith value.

   *  Header AEAD Algorithm: Same as AEAD Algorithm, but the key and
      algorithm used to protect the header fields in the session
      packets.  This value cannot change during the lifetime of the
      connection.  Presence signaled by Has Header Key.

   *  Header Key: Same as Key, but for the Header AEAD Algorithm.

      -  I assume it's not better to use a TLS CipherSuite because there
         is no KDF stage for deriving these keys (they are a strict
         server-to-client advertisement), so the Hash part would be
         unused? https://www.iana.org/assignments/tls-parameters/tls-
         parameters.xhtml#tls-parameters-4
         (https://www.iana.org/assignments/tls-parameters/tls-
         parameters.xhtml#tls-parameters-4)

   *  Integrity Hash Algorithm: the hash algorithm used in integrity
      frames Several candidate iana registries, not sure which one to
      use?  Some have only text for some possibly useful values:

      -  https://www.iana.org/assignments/named-information/named-
         information.xhtml#hash-alg (https://www.iana.org/assignments/
         named-information/named-information.xhtml#hash-alg)

      -  https://www.iana.org/assignments/tls-parameters/tls-
         parameters.xhtml#tls-parameters-18
         (https://www.iana.org/assignments/tls-parameters/tls-
         parameters.xhtml#tls-parameters-18)

      -  (text-only): https://www.iana.org/assignments/hash-function-
         text-names/hash-function-text-names.xhtml
         (https://www.iana.org/assignments/hash-function-text-names/
         hash-function-text-names.xhtml)

9.2.  MC_SESSION_JOIN

   An MC_SESSION_JOIN frame (type TBD-02) is sent from server to client
   and requests that a client join the given transport addresses and
   ports and process packets with the given Session ID according to the
   corresponding MC_SESSION_PROPERTIES.

   MC_SESSION_JOIN frames are formatted as shown in Figure 2.

   MC_SESSION_JOIN Frame {
     Type (i) = TBD-02 (experiments use 0xff3e8002),
     Session ID (i),
     MC_CLIENT_LIMIT Sequence Number (i),
     MC_CLIENT_SESSION_STATE Sequence Number (i),
     MC_SESSION_PROPERTIES Sequence Number (i)

                   Figure 2: MC_SESSION_JOIN Frame Format

   The sequence numbers are present to allow the client to distinguish
   between a broken sender that has performed an illegal action and an
   instruction that's based on updates that are out of sync (either one
   or more missing updates to MC_SESSION_PROPERTIES not yet received by
   the client or one or more missing updates to MC_CLIENT_LIMIT or
   MC_CLIENT_SESSION_STATE not yet received by the server).

   A client SHOULD perform the join if it has the sequence number of the
   corresponding sesssion properties and the client's limits will not be
   exceeded, even if the client sequence numbers are not up to date.  If
   the client does not join, it MUST send a MC_CLIENT_SESSION_STATE with
   "Declined Join" and a reason.

9.3.  MC_SESSION_LEAVE

   An MC_SESSION_LEAVE frame (type=TBD-03) is sent from server to client
   Server-to-client in unicast connection or inside session.

   MC_SESSION_LEAVE frames are formatted as shown in Figure 3.

   MC_SESSION_LEAVE Frame {
     Type (i) = TBD-03 (experiments use 0xff3e8003),
     Session ID (i),
     After Packet Number (i)

                  Figure 3: MC_SESSION_LEAVE Frame Format

   If After Packet Number is nonzero, wait until receiving that packet
   or a higher valued number before leaving.

9.4.  MC_SESSION_INTEGRITY

   MC_SESSION_INTEGRITY frames are formatted as shown in Figure 4.

MC_SESSION_INTEGRITY Frame {
  Type (i) = TBD-04..TBD-05 (experiments use 0xff3e8004 and 0xff3e8005),
  Session ID (i),
  Packet Number Start (i),
  [Length (i)],
  Packet Hashes (..)

             Figure 4: MC_SESSION_INTEGRITY Frame Format

   For type TBD-05, Length is present and is a count of packet hashes.
   For TBD-04, Length is not present and the packet hashes extend to the
   end of the packet.

   Packet hashes MUST have length with an integer multiple of the length
   indicated by the Hash Algorithm from the Session Properties.

9.5.  MC_SESSION_STREAM_BOUNDARY_OFFSET

   MC_SESSION_STREAM_BOUNDARY_OFFSET frames are formatted as shown in
   Figure 5.

   MC_SESSION_STREAM_BOUNDARY_OFFSET Frame {
     Type (i) = TBD-06 (experiments use 0xff3e8006),
     Session ID (i),
     Stream ID (i),
     Stream Offset (i)

          Figure 5: MC_SESSION_STREAM_BOUNDARY_OFFSET Frame Format

   Client must discard data before Stream Offset, and should start
   accepting stream data at Stream Offset as though it's a new stream
   with offset 0.

   A server must ensure that data beginning at the given stream offsets
   could equivalently begin a new stream, and are safe for clients to
   start processing in order to use this.  (Well-suited for boundaries
   of http server push objects, for example, which otherwise would need
   to start a new stream per object in order to be usable by late
   joiners.)

9.6.  MC_SESSION_ACK

   Client->Server on unicast connection.

   (TODO: Is it possible to reuse the multiple packet number space
   version of ACK_MP from Section 12.2 of
   [I-D.draft-ietf-quic-multipath], defining session id as the packet
   number space?  at 2022-04-12 they're identical.)

   MC_SESSION_ACK frames are formatted as shown in Figure 6.

     MC_SESSION_ACK Frame {
       Type (i) = TBD-07 (experiments use 0xff3e8007),
       Session ID (i),
       Largest Acknowledged (i),
       ACK Delay (i),
       ACK Range Count (i),
       First ACK Range (i),
       ACK Range (..) ...,
       [ECN Counts (..)],
     }

                   Figure 6: MC_SESSION_ACK Frame Format

9.7.  MC_PATH_RESPONSE

   MC_PATH_RESPONSE frames are sent from client to server in a unicast
   connection in response to an PATH_CHALLENGE received in a session.
   Like PATH_RESPONSE but includes a session id.

   MC_PATH_RESPONSE frames are formatted as shown in Figure 7.

   MC_PATH_RESPONSE Frame {
     Type (i) = TBD-08 (experiments use 0xffe38008)
     Session ID (i),
     Data (64)
   }

                  Figure 7: MC_PATH_RESPONSE Frame Format

9.8.  MC_CLIENT_LIMITS

   MC_CLIENT_LIMITS frames are formatted as shown in Figure 8.

   MC_CLIENT_LIMITS Frame {
     Type (i) = TBD-09 (experiments use 0xff3e8009),
     Client Limits Sequence Number (i),
     Permit IPv4 (1),
     Permit IPv6 (1),
     Reserved (6),
     Max Aggregate Rate (i),
     Max Session IDs (i)

                  Figure 8: MC_CLIENT_LIMITS Frame Format

   Max Aggregate Rate allowed across all joined sessions is in Kibps.

9.9.  MC_SESSION_RETIRE

   MC_SESSION_RETIRE frames are formatted as shown in Figure 9.

   MC_SESSION_RETIRE Frame {
     Type (i) = TBD-0a (experiments use 0xff3e800a),
     Session IDs (i)

                  Figure 9: MC_SESSION_RETIRE Frame Format

   Retires a session by id.  (We can't use RETIRE_CONNECTION_ID because
   we don't have a coherent sequence number.)

9.10.  MC_CLIENT_SESSION_STATE

   MC_CLIENT_SESSION_STATE frames are formatted as shown in Figure 10.

   MC_CLIENT_SESSION_STATE Frame {
     Type (i) = TBD-0b (experiments use 0xff3e800b),
     Client Session State Sequence Number (i),
     State (i),
     Reason (0..i)

              Figure 10: MC_CLIENT_SESSION_STATE Frame Format

   State has possible values:

   *  0x0: Left

   *  0x1: Declined Join

   *  0x2: Joined

   For Left, Reason must be set to one of:

   *  0x0: Left as requested by server

   *  0x1: Protocol Error

   *  0x2: Property Violation

   *  0x3: High Loss

   *  0x4: Exceeded max idle time

   *  0x5: Administrative change

   *  0x6: other

   For Declined Join, Reason must be set to one of:

   *  Protocol Violation (limits exceeded, unsupported ciphersuite, etc)

   *  held-down (prior session failures, administrative block)

   (TODO: Should we include a loggable string in this?)

   (TODO: Or should we try to reuse PATH_ABANDON and/or PATH_STATUS?  I
   don't think they're sufficient, but maybe?): -
   [I-D.draft-ietf-quic-multipath] -
   https://datatracker.ietf.org/doc/html/draft-liu-multipath-quic-
   04#section-9.1 (https://datatracker.ietf.org/doc/html/draft-liu-
   multipath-quic-04#section-9.1)

   The things server needs to know for state changes _could_ maybe be
   inferred from ack responses but explicit seems better, allowing for a
   more proactive response under strain?

10.  Frames Carried in Session Packets

   MC Sessions will contain normal quic 1-rtt data packets (see
   Section 17.3.1 of [RFC9000]) except using the Session ID instead of a
   Connection ID.  The packets are protected with the keys from
   MC_SESSION_PROPERTIES for the corresponding session.

   Data packet hashes will also be sent in MC_SESSION_INTEGRITY frames,
   as keys cannot be trusted for integrity due to giving them to too
   many receivers, as in [I-D.draft-krose-multicast-security].

   The 1-rtt packets in multicast sessions will have a restricted set of
   frames.  Since the session is strictly 1-way server to client, the
   general principle is that broadcastable shared server->client data
   frames can be sent, but frames that make sense only for
   individualized connections cannot.

   Permitted:

   *  PADDING Frames ([RFC9000] Section 19.1)

   *  PING Frames ([RFC9000] Section 19.2)

   *  RESET_STREAM Frames ([RFC9000] Section 19.4)

   *  STREAM Frames ([RFC9000] Section 19.8)

   *  DATAGRAM Frames (both types) ([RFC9221] Section 4)

   *  PATH_CHALLENGE Frames ([RFC9000] Section 19.17)

   *  MC_SESSION_PROPERTIES

   *  MC_SESSION_LEAVE (however, join must come over unicast?)

   *  MC_SESSION_INTEGRITY (not for this session, only for another)

   *  MC_STREAM_BOUNDARY_OFFSET

   *  MC_SESSION_RETIRE

   Not permitted:

   *  19.3.  ACK Frames

   *  19.6.  CRYPTO Frames (crypto handshake does not happen on mc
      sessions)

   *  19.7.  NEW_TOKEN Frames

   *  Flow control is different:

      -  19.5.  STOP_SENDING Frames

      -  19.9.  MAX_DATA Frames (flow control for mc sessions is by
         rate)

      -  19.10.  MAX_STREAM_DATA Frames

      -  19.11.  MAX_STREAMS Frames

      -  19.12.  DATA_BLOCKED Frames

      -  19.13.  STREAM_DATA_BLOCKED Frames

      -  19.14.  STREAMS_BLOCKED Frames

   *  Session ID Migration can't use the "prior to" concept, not
      0-starting

      -  19.15.  NEW_CONNECTION_ID Frames

      -  19.16.  RETIRE_CONNECTION_ID Frames

   *  19.18.  PATH_RESPONSE Frames

   *  19.19.  CONNECTION_CLOSE Frames

   *  19.20.  HANDSHAKE_DONE Frames

   *  MC_PATH_RESPONSE

   *  MC_CLIENT_LIMITS

   *  MC_CLIENT_SESSION_STATE

   *  MC_SESSION_ACK

11.  Error Codes

12.  Security Considerations

   Mostly incorporate [I-D.draft-krose-multicast-security].  Anything
   else?

   e.g. if a different legitimate quic connection says someone else's
   quic multicast stream is theirs, that's maybe a problem worth
   protecting against.  Maybe we need a periodic asymmetric challenge?
   I'm thinking send a public key on the multicast channel and in the
   unicast channels send an individualized MAC signed with the private
   key and verify it with the public key, so that in addition to
   validating that the unicast server knows the contents of the
   multicast packets via the hashes it supplies, the multicast stream
   provides a way for the client to validate that the unicast stream is
   authorized to use it for data transport via proof they know the
   private key corresponding to the public key that arrived on the
   multicast session.  (Note this doesn't prevent unauthorized receipt
   of multicast data packts, but does prevent a quic server from lying
   when claiming a multicast data channel belongs to it, preventing
   legit receivers from consuming it.)

   (alternatively, can the multicast channel just periodically say what
   domain name is expected for the quic connection and get the same
   crypto guarantee of a proper sender via the domain's cert, which was
   already checked on the unicast channel?)

13.  IANA Considerations

   TODO: lots

14.  Normative References

   [I-D.draft-ietf-quic-multipath]
              Liu, Y., Ma, Y., Coninck, Q. D., Bonaventure, O., Huitema,
              C., and M. Kuehlewind, "Multipath Extension for QUIC",
              Work in Progress, Internet-Draft, draft-ietf-quic-
              multipath-01, 7 March 2022,
              <https://datatracker.ietf.org/doc/html/draft-ietf-quic-
              multipath-01>.

   [I-D.draft-krose-multicast-security]
              Rose, K. and J. Holland, "Security and Privacy
              Considerations for Multicast Transports", Work in
              Progress, Internet-Draft, draft-krose-multicast-security-
              02, 31 January 2022,
              <https://datatracker.ietf.org/doc/html/draft-krose-
              multicast-security-02>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC9000]  Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
              Multiplexed and Secure Transport", RFC 9000,
              DOI 10.17487/RFC9000, May 2021,
              <https://www.rfc-editor.org/rfc/rfc9000>.

   [RFC9221]  Pauly, T., Kinnear, E., and D. Schinazi, "An Unreliable
              Datagram Extension to QUIC", RFC 9221,
              DOI 10.17487/RFC9221, March 2022,
              <https://www.rfc-editor.org/rfc/rfc9221>.

Acknowledgments

   TODO acknowledge.

Authors' Addresses

   Jake Holland
   Akamai Technologies, Inc.
   Email: jakeholland.net@gmail.com


   Lucas Pardue
   Email: lucaspardue.24.7@gmail.com
